# 📘 System Design – README
*link for system architecture : https://viewer.diagrams.net/?tags=%7B%7D&lightbox=1&highlight=0000ff&edit=_blank&layers=1&nav=1&title=eurisko%20assignment%201.drawio&dark=auto#R%3Cmxfile%3E%3Cdiagram%20name%3D%22Page-1%22%20id%3D%22N9AK9QqKOTyJwIi_XA6O%22%3E7V3td6I6Gv9rPKf9UA7vLx9bW3fu3rm7vdOZnXs%2FeSJEzRaJC9jW%2Bes3gQQhgoII6oydc0YJSQjJ73nyvMaBNlx8%2FCMEy%2Fkf2IP%2BQJW9j4H2OFBVxZQ18kFL1mmJbRppwSxEHqu0KXhBPyAr5KUr5MGoUDHG2I%2FRsljo4iCAblwoA2GI34vVptgvPnUJZnCr4MUF%2Fnbpd%2BTFc1aqy%2FLmxieIZnP2aNtgNxaAV2YF0Rx4%2BD1XpD0NtGGIcZx%2BW3wMoU8nj89L2m5UcTcbWAiDuE4DX5XX3%2BD8%2FnW0gv9xf5ffptqfd6yXN%2BCv2AsPVNMn%2FT146I18ndGvvGiKyZPIi8RrNjvm%2F1aY37iLkrW7JxUUffmRNmP3eUffIhiS%2B4%2B0ACyWpCSYRMvcE8jo04cUH0yKC8NRC6NQ0SJZxAcQLVMITNEHJG%2F9MI8XPrlUyNclRkGcYMF4GBiPtLaPZgEpcMn8kWGlb8EAqJDVeWDdPqLFjAzARxPyP%2FixCiGdZA%2FEYAIiAk11dE8Lx4%2BsZPyMo3gWwpc%2FP49fYPgGQyl6m2XjJtcx%2FKhcQyVDBiEpiBcwDtekCm9gKaakqWkzTlG2pNpO7i%2B9%2B75Bq6VJNnvUPAdVx5Z01hVgVDLLnrgBEvnCsNQAV2olrlqD6DnE3sqlfYDAo2gK8ZKDqhxEvzRcClhRNVnKQ8WxtsGiS4pWChZb7wgsWndg%2BXfobVjOFR0COnSngA5DsSWzBBHV7EPpCBF6d4j4A08QaarK90vKNj59%2Ffr8MqBb52jPJtTFhijug9%2Fh5AW7rzDmI5KfV9GcfNyMhn%2B02yQj0qtLV1Qmd%2FEq9lEAh5nQJLNBD7GPw6SBRv6N6JI9zELgIbi5F%2BCAEsgU%2Bb5YnZJCFIf4FQqVPRDNKRUlD6KoRUTE%2Bgwm0CcARzHClHgmOI7xIlfhnlFVjJdlNJajSJHckmv28nIZNSckDMOnN5hSMu2ESGhL2mDxMaPCrATeI11aJHgZuz5KyOoohKfIkpz%2FUwpkqMulZGhYkl3CmElnHRGh0R0REpxTmT2Z05sJldJheNtQKOyCHhk3GOXocPTl6eXrmZFekcTyDQSinCZ%2F50h%2FpbQWwgivQhf%2B5tLxPJDL9Fux1jFJ0XIyomLUp%2FBOcqRn29t0x8uOTnZ2ryrZ%2FfNvVMsGMXwH6xuG%2F2GK%2BSH9Ru7c%2BWiByGOGPgZU4p4AHwQulat2UkW0BEGjsZGO3ddZiFeBd%2BemIKb34xAEEV%2FSh0TXz%2B75dEHuPBC%2B3oSzyY2cDFrmH7fpJ72jGkZ6kf9ye1s6J7e5F0tfYje5V67OJGzIKZJ3z%2Bj0fY5i%2BLIELr37TgigSHMeCglNpaRL6IaC9RgkYShWkSBMfYsgVNnZpgjV7EocdLrbiXZyd2F1YODdU5MS5YE%2BiCLkJrwYhPF2cW6diotKViFc%2F0UvKOdh138n145t8ILHj3z1x3X%2B6hmGiMwrZcFJYbobcOuUlo0celumLQED5O0SfrtfEicvOYPxPq61jam8%2FCJvQ4aXhdAHMXorDrcMRuwJz1R620A2s7FlEpRg10hfk7XK28jEjqxiR5ohdJTOw1ZHCaqz1z4c6EqHdpOcTNMj3K%2Fg1GS7iClbENjrglMzhI40oaOuwdmhVn5KNqwaeTas7GHBnQLauARA63JRQFC5vbApoC2lCOhMqugL0NbPxm1zqNYctQBrSVbUPdDuX7q4DLwbRfuMqRkH4t0Q7K1Wz9JFv6ol8%2FZRszVyqcX1ZhniKfKpmXvY0KLSnwl2in2fkJs6WgX8K9UW3%2BFkjvFrdNtw4G0UvMERTI2q4C1UZI1ueKJCp9jWNv2YtmRUE0s7%2F2Ajx3NjS4K4yMMQghgLaHR5YaXZsZXy33rQZKYB9QylAFxmbk9EEPSBgllTM8W5QVHVti1tfePQOIKR26hYP%2BaYhqmLoa4YQLZVbjjFYTzHMxwA%2F2lTKuz4mzqfMbXSJqv1XxjHa2aOBasYF9eSgCf%2BK%2Fc9NT5YBrvcCAf0ohexV1VrygGGVg6x2jt8O6ZVrZ13Qf8MPzmOFblz6K0S76VHbkaMM6wmPqJewjPhWyJD9Yp0QIe8AAF1h9OngBhGl87JNFM7OSfTOzSSfsK0%2FZBMM9ELrqxsJyvTarIyvUKnaamsKKZWVDJMs56ViGiZYJ2rxmJcqh%2BkK4I2wxxpVdqPYirqrgY09iUZw1F1HrU6uKgL3sfjjXJMO4QupOupypjeFJSf82LVyIOLJY5h4K5TRp343kDqZVJlH8%2BQe%2BnMWndqqj%2BW1RGr5hTZhdBJ44VosFC1nno6Ls058d%2B58lOw6LpuA%2F0YHLoxX826ZHi1ZHMnX818VAfW15l%2Ft1M2bFbr%2B60h%2Fx1Oomam1h4hz7wLF4R64zSoN4u%2BAIuFnFZKE0qb6grLQulW9Kj2l3Wxl%2F8Lx2iKXMD26ryhCwfRagGLOtiZSiDLNN71DQHyfz4MT9jTLkLyEDi5qVgSdwafUFPUOnR7fXmutuyfkgtbeS6cMd5SLrzxoQ20fHTOvticTrk3N5Xu5d5KW7WyHbSqPUw%2FKbSU2rg6D3xU8aye8NFlJN%2F540PabZi6bM6TWsdPhSz9CDr15SJrt15x4bg6qc9HP4Lielm4EoSlnxpabS087TbDDqF1T9MBckpgPZT1rSE5PE6bRwSU5CMrPEe9n6Q3rSwgQCTGslC96pi8jK4uXAexa1KV1lbELDfh2E5Rm94Kf64bhufs66jjMDzN7I7u%2F%2Fn9K10iAoKgkZ82SQUcJCl36AeYZHl7eXovyQAUEwUXyPOS3Sh9CDuUhfU3yNI09jCNHYR5MjGgzJZXhy00juBtozfcyZKsOwLLOMOwX6UuK6ngJP3E%2FSqmkBqqOuphHEexNKEn8eCVjlmOfuiudnAAOoWiKuS3KYp5CBQPIYluXSm15cuTwlcziqA7OCtO0eViT32nxekd7pjflh6IeURdsqh0t%2Bo1aePs8K1e8d0vvss8Mr8G1OqGy1UYgX4ZqDV2qBs8zIlH26m2AN0OXN56vxlGX6CHyBzIQ38VxUnc3c0cp11i91V0LVcy9b5TjtwskHaYphglQ3eBO6f70DklR0VzHMZ3ZKyLZOWz4MCWWVBdn0U1dFQjPdHp5zqLKvSi8WLlx2gMfoy9ydhluD9OuIIh5DlaWok1jvdbsMZ1pnZz5thdUDvnFIeLeyc6%2BuCkKbFEkyseLGny6%2BYbohhGXjMptnm8ul3cEC25h7hH4zjh5yc6GEluEMVVfeBRNwFm1ym5Tsl1Sq5Tcp2S65Rcp%2BQ6JdcpuU7JgVPyO5i%2Bghtq%2Fx8fPUGijyNrkrzS%2FNDlIJcLUvpO53XmDgroEHG4HrtzEMxg41N2almdSk7t33HG%2F5aFJ%2Fv9FqrbF2xIgvVpNDLv5Y0BQDy7WTTs%2BGgCJmDs%2BnjlSa8Uitng29lzHL14TptmyBJPwS6YdCyJpyoVzvfXs4OCjm%2FXOYJDryodkKdgP13EuSuDemFgkuwIznTL2XdSYf9xHbW9Oa3PcTnQBCTYmnRL%2BMkksYGjGi0bqD0kGhpHyLqpoqagmFXI9xL26xTC0S69nd9fNdp0VJhxgD0nL9XaNPrgCxsqP6OTSOuScusY6nJKIsRapCRb%2FPmh2mc6m4Lh11aEno5kYd4assbCmStHtvWO7IDISvZiC%2BdTN27gmPbuBhqfnPIGTRkYudz8wl1affM7gdrT%2FwE%3D%3C%2Fdiagram%3E%3C%2Fmxfile%3E


## 🔹 Database Schema

The platform uses a **relational database (PostgreSQL)** with **UUID primary keys** for scalability and distributed consistency.  

### **Entities & Relationships**

#### 1. **User**
- **Fields**:  
  - `user_id (PK, UUID)`  
  - `username (unique)`  
  - `email (unique)`  
  - `password_hash`  
  - `created_at`  
- Relationships:  
  - Can place multiple **Orders**.  
  - Can follow/unfollow other users (via **User_Follow**).  
  - Can receive many **Notifications**.  
  - One-to-one with **Creator** (a user may become a creator).  

---

#### 2. **Creator**
- **Fields**:  
  - `creator_id (PK, UUID)`  
  - `user_id (FK → User.user_id)`  
  - `creator_name`  
  - `created_at`  
- Relationships:  
  - A creator is always linked to a **User**.  
  - Can list multiple **Products**.  

---

#### 3. **Product**
- **Fields**:  
  - `product_id (PK, UUID)`  
  - `creator_id (FK → Creator.creator_id)`  
  - `product_name`  
  - `description`  
  - `product_price`  
  - `stock_quantity`  
  - `status (active/inactive)`  
  - `created_at`  
- Relationships:  
  - Belongs to a **Creator**.  
  - Can have multiple **Drops**.  

---

#### 4. **Drop**
- **Fields**:  
  - `drop_id (PK, UUID)`  
  - `product_id (FK → Product.product_id)`  
  - `scheduled_time`  
  - `status (scheduled, live, ended, cancelled)`  
  - `created_at`  
- Relationships:  
  - A **Product** can have multiple **Drops**.  
  - A **Drop** can have multiple **Orders**.  

---

#### 5. **Order**
- **Fields**:  
  - `order_id (PK, UUID)`  
  - `user_id (FK → User.user_id)`  
  - `drop_id (FK → Drop.drop_id)`  
  - `status (pending, confirmed, failed, cancelled)`  
  - `total_amount`  
  - `payment_id (external reference)`  
  - `created_at`  
- Relationships:  
  - Placed by a **User** during a **Drop**.  
  - Contains multiple **Order_Items**.  

---

#### 6. **Order_Item**
- **Fields**:  
  - `order_item_id (PK, UUID)`  
  - `order_id (FK → Order.order_id)`  
  - `product_id (FK → Product.product_id)`  
  - `quantity`  
  - `price`  
- Relationships:  
  - Belongs to an **Order**.  
  - Links a **Product** to an **Order**.  

---

#### 7. **User_Follow**
- **Fields**:  
  - `follower_id (FK → User.user_id)`  
  - `followed_id (FK → User.user_id)`  
  - `created_at`  
- Relationships:  
  - Many-to-many between **Users**.  
  - Used for social features (followers & following).  

---

#### 8. **Notification**
- **Fields**:  
  - `notification_id (PK, UUID)`  
  - `user_id (FK → User.user_id)`  
  - `type (order_update, drop_event, system)`  
  - `message`  
  - `status (unread/read)`  
  - `created_at`  
- Relationships:  
  - Belongs to a **User**.  
  - Used for real-time updates (orders, drops, system messages).  

---

### **Entity Relationships Overview**
- **User ↔ Creator** → One-to-One  
- **Creator ↔ Product** → One-to-Many  
- **Product ↔ Drop** → One-to-Many  
- **Drop ↔ Order** → One-to-Many  
- **Order ↔ Order_Item** → One-to-Many  
- **User ↔ Order** → One-to-Many  
- **User ↔ User_Follow** → Many-to-Many  
- **User ↔ Notification** → One-to-Many  

---


## 📖 Overview

This system is designed to support a **high-traffic product drop platform** with features such as:

- Real-time product releases ("drops").
- Secure order processing with idempotency.
- Social features (follow/unfollow creators).
- Scalable notification delivery via WebSockets and push (FCM).

The architecture is **microservices-based**, combining **synchronous RPC** for critical paths and **asynchronous Kafka events** for scalability and decoupling.  
Caching is handled through **Redis Cluster**, while **API Gateway** provides **load balancing, rate limiting, and authentication enforcement**.

---

## 🔹 API Contract Outline

### **Public APIs** (via API Gateway)

The **API Gateway** is the single entry point for **Web clients** and **Mobile apps**. It provides:

- **Load Balancing** across service replicas.
- **Rate Limiting** to protect services from abuse.
- **Authentication** by validating JWT tokens.

#### Endpoints:

- **Auth Service**

  - `POST /auth/login` → Authenticate, return JWT token.
  - `POST /auth/refresh` → Refresh expired token.
  - `POST /auth/logout` → Invalidate session/token.

- **User Service**

  - `GET /users/{id}` → Fetch user profile.
  - `POST /users/{id}/follow` → Follow a user.
  - `DELETE /users/{id}/follow` → Unfollow a user.
  - **Webhooks** → Notify clients of profile or follow/unfollow changes.

- **Creator Service**

  - `GET /creators/{id}` → Fetch creator metadata.
  - `GET /creators/{id}/products` → List creator products.
  - `POST /creators/{id}/products` → Add products (creator only).

- **Drop Service**

  - `GET /drops/upcoming` → List upcoming drops.
  - `GET /drops/{id}` → Fetch drop details.
  - **WebSocket** → Subscribe to live drop announcements.

- **Order Service**

  - `POST /orders` → Place an order (requires idempotency key).
  - `GET /orders/{id}` → Fetch order status.

- **Notification Service**
  - **WebSocket / Push (FCM)** → Notify users of order updates, drops, and stock changes.

---

### **Internal APIs (RPC Connections)**

The system uses **RPC** for synchronous calls between services. The **Auth Service** acts as a **central trust authority** and communicates with all core services.

#### RPC interactions:

1. API Gateway → Auth Service (token validation).
2. Auth Service → User Service (identity, profile validation).
3. Auth Service → Creator Service (authenticate creator actions).
4. Auth Service → Drop Service (authorize scheduling & publishing).
5. Auth Service → Order Service (authenticate before placing orders).
6. Auth Service → Notification Service (validate sessions/subscriptions).
7. Drop Service → Order Service (sync drop states with orders).
8. Order Service → Notification Service (push order events).

---

### **Internal APIs (Event-driven via Kafka)**

Kafka ensures **loose coupling** and **scalable event distribution**.

- **Drop Service → Kafka**: Publishes `drop_events`.
- **Order Service → Kafka**: Publishes `order_events`.
- **Notification Service → Kafka**: Consumes `notification_events`.
- **Inventory changes → Kafka**: Broadcasts stock updates.

---

## 🔹 Caching & Invalidation Strategy

### **Redis Cluster**

Used for:

- **Hot stock counters** → Real-time stock tracking during drops.
- **Follower cache** → Speeds up social graph lookups.
- **Idempotency keys** → Prevents duplicate order submissions.

### **Invalidation Strategy**

- **Write-through caching (Orders/Stock)**

  - Order Service updates Redis counters immediately when orders are placed.
  - Periodic reconciliation with DB ensures consistency.

- **Event-driven invalidation (Kafka)**

  - `order_events`, `inventory_changes` trigger cache refreshes.

- **TTL-based eviction**
  - Idempotency keys: expire after a few minutes.
  - Follower cache: longer TTL, refreshed periodically or on change events.

---

## 🔹 Tradeoffs & Reasoning

### **API Gateway (Load Balancer + Rate Limiter)**

- ✅ Pros: Protects backend, enforces fair usage, balances requests across replicas.
- ⚠️ Cons: Must be deployed in high-availability mode to avoid single point of failure.

### **JWT Authentication**

- ✅ Pros: Stateless, scalable.
- ⚠️ Cons: Token revocation is hard → mitigated with short TTLs and refresh tokens.

### **RPC + Kafka Hybrid**

- ✅ RPC: Low-latency for critical synchronous flows (auth, orders).
- ✅ Kafka: Scalable async communication for drops, notifications, and inventory.
- ⚠️ Cons: Added complexity in managing two communication models.

### **Redis for Hot Stock + Idempotency**

- ✅ Pros: Sub-millisecond performance for high-traffic events.
- ⚠️ Cons: Requires reconciliation with DB for consistency.

### **Idempotency in Orders**

- ✅ Prevents duplicate orders during retries.
- ⚠️ Needs additional Redis storage for temporary keys.

### **Real-time Notifications**

- ✅ Improves UX with instant updates.
- ⚠️ Requires robust WebSocket infrastructure to handle disconnects and scaling.

---

## 🔹 Summary

This design achieves:

- **Scalability** → API Gateway, load balancing, Kafka event distribution.
- **Performance** → Redis caching for hot paths.
- **Reliability** → Idempotent orders, DB reconciliation.
- **Great UX** → Real-time WebSocket and FCM notifications.

By carefully combining **load balancing, rate limiting, caching, RPC, and event-driven messaging**, the system can handle **high-traffic product drops** reliably and at scale.

---
